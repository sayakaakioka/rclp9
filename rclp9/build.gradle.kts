/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Java library project to get you started.
 * For more details on building Java & JVM projects, please refer to https://docs.gradle.org/8.5/userguide/building_java_projects.html in the Gradle documentation.
 */
import java.io.ByteArrayOutputStream

plugins {
    // Apply the java-library plugin for API and implementation separation.
    `java-library`

    // apply eclipse plugin to generate .classpath
    `eclipse`
}

repositories {
    // Use Maven Central for resolving dependencies.
    mavenCentral()
    maven { url = uri("https://jogamp.org/deployment/maven/") }
}

dependencies {
    // This dependency is exported to consumers, that is to say found on their compile classpath.
    //api(libs.commons.math3)

    // This dependency is used internally, and not exposed to consumers on their own compile classpath.
    implementation(libs.guava)

    // Processing core libraries
    implementation(libs.processing.core)

    // https://mvnrepository.com/artifact/org.apache.commons/commons-lang3
    implementation(libs.commons.lang3)
}

testing{
    suites {
        // Define a test suite
        val test by getting(JvmTestSuite::class) {
            // Use JUnit Jupiter test engine
            useJUnitJupiter()

            dependencies {
                implementation(platform(libs.junit.bom))
                implementation(libs.jupiter)
                implementation(libs.processing.core)
            }

            targets.all{
                testTask.configure {
                    // Show standard out and standard error of the test JVM(s) on the console
                    testLogging.showStandardStreams = true

                    systemProperty(
                        "java.library.path",
                        "${projectDir}/libs/rclp9:${projectDir}/libs/ros:${projectDir}/libs"
                    )

                    jvmArgs(
                        "-Xcheck:jni",
                        "-Xlog:jni=trace",
                        "-XX:ErrorFile=${layout.buildDirectory.get().asFile}/hs_err_%p.log",
                        "-XX:+CreateCoredumpOnCrash"
                    )
                }
            }
        }
    }
}

java{
    toolchain{
        languageVersion.set(JavaLanguageVersion.of(21))
    }
}

fun detectRosRoot(): File? {
    val candidates = listOf (
        (findProperty("ROS_ROOT") as String?)?.ifBlank { null },
        System.getenv("ROS_ROOT")?.ifBlank { null },
        "/opt/ros/humble",
        "/opt/ros/jazzy",
        "/opt/ros/kilted"
    ).filterNotNull()

    return candidates.map(::File).firstOrNull { it.exists() }
}

val rosRoot: File? = detectRosRoot()
val rosDistro: String? = rosRoot?.name
val rosInclude: File? = rosRoot?.resolve("include")
val rosLibOrg: File? = rosRoot?.resolve("lib")

val baseModules = listOf(
    "builtin_interfaces",
    "geometry_msgs",
    "rcl",
    "rcl_yaml_param_parser",
    "rcutils",
    "rmw",
    "rosidl_runtime_c",
    "rosidl_typesupport_interface",
    "std_msgs"
)

val extraModules = when (rosDistro) {
    "kilted", "jazzy" -> listOf("service_msgs", "type_description_interfaces", "rosidl_dynamic_typesupport")
    else -> emptyList()
}

val moduleInclude = baseModules + extraModules

val baseLibs = listOf(
    "ament_index_cpp",
    "builtin_interfaces__rosidl_generator_c",
    "builtin_interfaces__rosidl_typesupport_c",
    "builtin_interfaces__rosidl_typesupport_fastrtps_c",
    "builtin_interfaces__rosidl_typesupport_introspection_c",
    "fastcdr",
    "geometry_msgs__rosidl_generator_c",
    "geometry_msgs__rosidl_typesupport_c",
    "geometry_msgs__rosidl_typesupport_fastrtps_c",
    "geometry_msgs__rosidl_typesupport_introspection_c",
    "rcl",
    "rcl_interfaces__rosidl_generator_c",
    "rcl_interfaces__rosidl_typesupport_c",
    "rcl_logging_interface",
    "rcl_logging_spdlog",
    "rcl_yaml_param_parser",
    "rcpputils",
    "rcutils",
    "rmw",
    "rmw_dds_common",
    "rosidl_runtime_c",
    "rosidl_typesupport_c",
    "rosidl_typesupport_cpp",
    "rosidl_typesupport_fastrtps_c",
    "rosidl_typesupport_fastrtps_cpp",
    "rosidl_typesupport_introspection_c",
    "rosidl_typesupport_introspection_cpp",
    "std_msgs__rosidl_generator_c",
    "std_msgs__rosidl_typesupport_c",
    "std_msgs__rosidl_typesupport_fastrtps_c",
    "std_msgs__rosidl_typesupport_introspection_c",
    "tracetools"
)

val extraLibs = when (rosDistro) {
    "kilted", "jazzy" -> listOf(
        "service_msgs__rosidl_generator_c",
        "type_description_interfaces__rosidl_generator_c",
        "type_description_interfaces__rosidl_typesupport_c",
        "rosidl_dynamic_typesupport",
        "rosidl_dynamic_typesupport_fastrtps"
    )
    else -> emptyList()
}

val moduleLib = baseLibs + extraLibs

tasks.named("jar") {
    doLast {
        // copy rclp9 folder into your sketchbook/libraries
        val targetDir = "${projectDir}/build/rclp9/library"
        exec {
            commandLine("/usr/bin/mkdir", "-p", targetDir)
        }

        copy {
            from("${projectDir}/build/libs")
            into(targetDir)
            include("*.jar")
        }

        copy {
            from("${projectDir}/libs/ros")
            from("${projectDir}/libs/rclp9")
            into(targetDir)
            include("lib*")
        }
    }
}

tasks.named<Delete>("clean"){
    doLast {
        project.delete("${projectDir}/libs/rclp9", "${projectDir}/libs/ros")
    }
}

tasks.withType<JavaCompile> {
    options.compilerArgs.addAll(listOf("-Xlint:deprecation", "-Xdiags:verbose"))
}

val jniHeadersDir = layout.buildDirectory.dir("generated/sources/headers/java/main")
tasks.withType<JavaCompile>().configureEach {
    options.compilerArgs.addAll(listOf("-h", jniHeadersDir.get().asFile.absolutePath))
}

fun jniIncludeArgs(): List<String> {
    val launcher = javaToolchains.launcherFor { languageVersion.set(JavaLanguageVersion.of(21)) }.get()
    val javaHome = launcher.metadata.installationPath.asFile
    val inc = javaHome.resolve("include")
    val osInc = inc.resolve("linux")
    return listOf(
        "-I${jniHeadersDir.get().asFile.absolutePath}",
        "-I${inc.absolutePath}",
        "-I${osInc.absolutePath}"
    )
}

fun rosIncludeArgs(): List<String> =
    if (rosInclude?.exists() == true)
        moduleInclude.map { "-I${rosInclude.resolve(it).absolutePath}" }
    else emptyList()

val rclp9LibDir: Directory = layout.projectDirectory.dir("libs/rclp9")
val rosLibDir: Directory = layout.projectDirectory.dir("libs/ros")

val syncRosLibs by tasks.registering(Sync::class) {
    if (rosLibOrg != null && moduleLib.isNotEmpty()) {
        from(rosLibOrg) { include(moduleLib.map { "lib$it.so*" }) }
        into(rosLibDir)
    }
}

fun gpp(): String = System.getenv("CXX") ?: "g++"

val withDebug = (findProperty("nativeDebug") as String?)?.toBooleanStrictOrNull() ?: true
val projectInclude = "${projectDir}/src/main/cpp/include"
val commonCompileFlags = mutableListOf("-shared", "-fPIC", "-std=c++17", "-I${projectInclude}").apply { if (withDebug) add("-g") }

val cppDir = layout.projectDirectory.dir("src/main/cpp")
val cppFiles = fileTree(cppDir) { include("**/*.cpp") }.files.sorted()

val buildNative by tasks.registering {
    group = "build"
    description = "Build JNI native libs (.so) from src/main/cpp/*.cpp"
    dependsOn(syncRosLibs, tasks.named("compileJava")) 
}

val probeOutFile = layout.buildDirectory.file("generated/probe_rcl_timer_init2.txt")
tasks.register("probeRclTimerInit2") {
    outputs.file(probeOutFile)
    doLast {
        val dir = probeOutFile.get().asFile.parentFile
        dir.mkdirs()
        val probeCpp = File(dir, "probe_rcl_timer_init2.cpp")
        val probeObj = File(dir, "probe_rcl_timer_init2.o")
        probeCpp.writeText(
            """
            #include <rcl/timer.h>
            int main() {
                (void)&::rcl_timer_init2;
                return 0;
            }
            """.trimIndent()
        )

        val cmd = mutableListOf<String>()
        cmd += gpp()
        cmd += commonCompileFlags

        cmd += rosIncludeArgs()
        cmd += listOf("-c", probeCpp.absolutePath, "-o", probeObj.absolutePath)

        val output = ByteArrayOutputStream()
        val result = exec {
            commandLine(cmd)
            isIgnoreExitValue = true
            standardOutput = output
            errorOutput = output
        }

        val hasInit2 = (result.exitValue == 0)
        probeOutFile.get().asFile.writeText( if (hasInit2) "1" else "0" )
        logger.lifecycle("probe rcl_timer_init2: ${if (hasInit2) "FOUND" else "NOT FOUND"}")
    }
}

cppFiles.forEach { src ->
    val base = src.nameWithoutExtension
    val outSo = rclp9LibDir.file("lib${base}.so").asFile

    val t = tasks.register<Exec>("buildSo_${base}") {
        group = "build"
        dependsOn(syncRosLibs, tasks.named("compileJava"), tasks.named("probeRclTimerInit2"))
        doFirst {
            outSo.parentFile.mkdirs()
            rosLibDir.asFile.mkdirs()

            // check if rcl_timer_init2 is available
            val hasInit2 = probeOutFile.get().asFile.takeIf { it.exists() }?.readText()?.trim() == "1"

            // build command for compiling the actual source file
            val cmd = mutableListOf<String>()
            cmd += gpp()
            cmd += commonCompileFlags
            if (hasInit2) {
                cmd += "-DHAS_RCL_TIMER_INIT2=1"
            }
            cmd += jniIncludeArgs()
            cmd += rosIncludeArgs()
            cmd += listOf("-o", outSo.absolutePath, src.absolutePath)
        
            if (rosLibOrg?.exists() == true) {
                cmd += "-L${rosLibDir.asFile.absolutePath}"
                moduleLib.forEach { cmd += "-l$it" }
            }

            commandLine(cmd)
            // println(cmd.joinToString(" "))
        }

        doLast {
            exec { commandLine("bash", "-lc", "ldd -u ${outSo.absolutePath} || true") }
        }
    }
    buildNative.configure { dependsOn(t) }
}

tasks.named("test") {
    dependsOn(buildNative)
}

tasks.withType<Test>().configureEach {
    val pidFile = layout.buildDirectory.file("xvfb-${name}.pid").get().asFile

    // for tests on Actions
    environment("LIBGL_ALWAYS_SOFTWARE", "1")
    environment("MESA_LOADER_DRIVER_OVERRIDE", "llvmpipe")
    environment("__GLX_VENDOR_LIBRARY_NAME", "mesa")
    environment("NO_AT_BRIDGE", "1")
    systemProperty("jogl.disable.openglcore", "true")

    val inherited = System.getenv("LD_LIBRARY_PATH") ?: ""
    val rosPrefix = rosRoot?.absolutePath
        ?: System.getenv("ROS_ROOT")?.takeIf { it.isNotBlank() }
        ?: "/opt/ros/humble"
    environment(
        "LD_LIBRARY_PATH",
        listOf(
            "$rosPrefix/lib",
            file("${projectDir}/libs/rclp9").absolutePath,
            file("${projectDir}/libs/ros").absolutePath,
            file("${projectDir}/libs").absolutePath,
            inherited
        ).filter { it.isNotBlank() }.joinToString(":")
    )

    val pathPrev  = System.getenv("PATH") ?: ""
    environment("PATH", "$rosPrefix/bin:$pathPrev")
    environment("AMENT_PREFIX_PATH", listOf(rosPrefix, System.getenv("AMENT_PREFIX_PATH") ?: "").filter { it.isNotBlank() }.joinToString(":"))
    environment("COLCON_PREFIX_PATH", listOf(rosPrefix, System.getenv("COLCON_PREFIX_PATH") ?: "").filter { it.isNotBlank() }.joinToString(":"))
    environment("CMAKE_PREFIX_PATH", listOf(rosPrefix, System.getenv("CMAKE_PREFIX_PATH") ?: "").filter { it.isNotBlank() }.joinToString(":"))
    environment("RMW_IMPLEMENTATION", "rmw_fastrtps_cpp")

    doFirst {
        println("LD_LIBRARY_PATH for tests = ${System.getenv("LD_LIBRARY_PATH")}")

        val hasDisplay = System.getenv("DISPLAY")?.isNotBlank() == true
        if (!hasDisplay) {
            exec {
                commandLine("bash","-lc","command -v Xvfb >/dev/null 2>&1 || { echo 'ERROR: Xvfb not installed. sudo apt-get install -y xvfb'; exit 1; }")
            }
            exec {
                commandLine("bash","-lc","Xvfb :99 -screen 0 640x480x24 >/dev/null 2>&1 & echo $! > ${pidFile.absolutePath}")
            }
            environment("DISPLAY", ":99")
            systemProperty("java.awt.headless", "false")
        }
    }

    doLast {
        if (pidFile.exists()) {
            exec { commandLine("bash","-lc","kill $(cat ${pidFile.absolutePath}) >/dev/null 2>&1 || true") }
            pidFile.delete()
        }
    }
}
