/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package rclp9;

import java.util.Optional;
import java.util.concurrent.TimeUnit;
import java.util.logging.ConsoleHandler;
import java.util.logging.Level;
import java.util.logging.Logger;

import processing.core.*;

import rclp9.rcljava.RCLJava;
import rclp9.rcljava.interfaces.Callback;
import rclp9.rcljava.interfaces.MessageDefinition;
import rclp9.rcljava.node.BaseComposableNode;
import rclp9.rcljava.node.Node;
import rclp9.rcljava.publisher.Publisher;
import rclp9.rcljava.time.WallClockTimer;

public class RCLP9 extends BaseComposableNode {
    private static final Logger logger = Logger.getLogger(RCLP9.class.getName());
    {
        logger.addHandler(new ConsoleHandler());
        logger.setLevel(Level.INFO);
    }

    /**
     * The parent PApplet of this library.
     */
    @SuppressWarnings("unused")
    private PApplet parent;

    private Publisher<? extends MessageDefinition> publisher;

    /**
     * A constructor, usually called in the setup() method in the sketch
     * to initialize and start the library.
     *
     * @param p the parent PApplet
     */
    public RCLP9(final PApplet p, final String nodeName) {
        super(nodeName);
        this.parent = p;
        welcome();
    }

    public Publisher<? extends MessageDefinition> createPublisher(final Class<? extends MessageDefinition> messageType,
            final String topic) {
        return rclp9CreatePublisher(messageType, topic, node);
    }

    public WallClockTimer createWallClockTimer(final long period, final Callback callback) {
        return node.createWallClockTimer(period, TimeUnit.MILLISECONDS, callback);
    }

    /**
     * Anything here will be called whenever the parent sketch shuts down.
     */
    public void dispose() {
        shutdown();
    }

    public Publisher<? extends MessageDefinition> getPublisher() {
        return publisher;
    }

    public void publish(MessageDefinition message) {
        publish(message, publisher);
    }

    public void publish(MessageDefinition message, Publisher<? extends MessageDefinition> publisher) {
        Optional<Publisher<? extends MessageDefinition>> pub = Optional.ofNullable(publisher);
        pub.ifPresent((p) -> p.publish(message));
    }

    public void spinPublisher() {
        RCLJava.spin(this);
    }

    public void spinPublisherOnce() {
        RCLJava.spinOnce(this);
    }

    private Publisher<? extends MessageDefinition> rclp9CreatePublisher(
            final Class<? extends MessageDefinition> messageType,
            final String topic, Node node) {
        publisher = node.createPublisher(messageType, topic);
        return publisher;
    }

    public void shutdown() {
        logger.info("rclp9 is shutting down");
        RCLJava.shutdown();
    }

    private void welcome() {
        logger.info("rclp9 is starting");
    }
}
