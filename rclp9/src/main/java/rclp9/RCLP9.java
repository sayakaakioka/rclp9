/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package rclp9;

import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;
import java.util.logging.ConsoleHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.Objects;

import processing.core.*;

import rclp9.rcljava.RCLJava;
import rclp9.rcljava.interfaces.Callback;
import rclp9.rcljava.interfaces.MessageDefinition;
import rclp9.rcljava.node.ComposableNode;
import rclp9.rcljava.node.Node;
import rclp9.rcljava.publisher.Publisher;
import rclp9.rcljava.subscriber.Subscriber;
import rclp9.rcljava.time.WallClockTimer;

public final class RCLP9 implements ComposableNode {
    private static final Logger logger = Logger.getLogger(RCLP9.class.getName());
    {
        logger.addHandler(new ConsoleHandler());
        logger.setLevel(Level.INFO);
    }

    /**
     * The parent PApplet of this library.
     */
    @SuppressWarnings("unused")
    private final PApplet parent;

    private Publisher<? extends MessageDefinition> publisher;

    private Subscriber<? extends MessageDefinition> subscriber;

    private WallClockTimer wallclockTimer;

    private final String name;
    private final Node node;

    /**
     * A constructor, usually called in the setup() method in the sketch
     * to initialize and start the library.
     *
     * @param p the parent PApplet
     */
    public RCLP9(final PApplet p, final String nodeName) {
        this.parent = Objects.requireNonNull(p);

        RCLJava.init();
        this.name = Objects.requireNonNull(nodeName);
        this.node = RCLJava.createNode(this.name);
        welcome();
    }

    public final <T extends MessageDefinition> Publisher<T> createPublisher(final Class<T> messageType,
            final String topic) {
        this.publisher = node().createPublisher(messageType, topic);
        return (Publisher<T>) publisher;
    }

    public final <T extends MessageDefinition> Subscriber<T> createSubscriber(final Class<T> messageType,
            final String topic, Consumer<T> callback) {
        this.subscriber = node().createSubscriber(messageType, topic, callback);
        return (Subscriber<T>) subscriber;
    }

    public final WallClockTimer createWallClockTimer(final long period, final Callback callback) {
        this.wallclockTimer = node().createWallClockTimer(period, TimeUnit.MILLISECONDS, callback);
        return wallclockTimer;
    }

    /**
     * Anything here will be called whenever the parent sketch shuts down.
     */
    public final void dispose() {
        shutdown();
    }

    @Override
    public Node node() {
        return node;
    }

    public final void publish(final MessageDefinition message) {
        publish(Objects.requireNonNull(message), Objects.requireNonNull(publisher));
    }

    public final void publish(final MessageDefinition message, final Publisher<? extends MessageDefinition> publisher) {
        Objects.requireNonNull(publisher).publish(Objects.requireNonNull(message));
    }

    public final Publisher<? extends MessageDefinition> publisher() {
        return publisher;
    }

    public final void spin() {
        RCLJava.spin(this);
    }

    public final void spinOnce() {
        RCLJava.spinOnce(this);
    }

    public final void shutdown() {
        logger.info("rclp9 is shutting down");
        RCLJava.shutdown();
    }

    public final Subscriber<? extends MessageDefinition> subscriber() {
        return subscriber;
    }

    @Override
    public final String toString() {
        return ("Instance of " + RCLP9.class.getName() + ", name = " + name + ", handle = "
                + node.handle());
    }

    private final void welcome() {
        logger.info("rclp9 is starting");
    }
}
