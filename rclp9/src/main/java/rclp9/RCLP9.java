/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package rclp9;

import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;
import java.util.logging.ConsoleHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.Objects;

import processing.core.*;

import rclp9.rcljava.RCLJava;
import rclp9.rcljava.interfaces.Callback;
import rclp9.rcljava.interfaces.MessageDefinition;
import rclp9.rcljava.node.ComposableNode;
import rclp9.rcljava.node.Node;
import rclp9.rcljava.publisher.Publisher;
import rclp9.rcljava.subscriber.Subscriber;
import rclp9.rcljava.time.Timer;

/**
 * This class acts as a bridge, offering access to RCL 
 * from Processing the environment.
 */
public final class RCLP9 implements ComposableNode {
    private static final Logger logger = Logger.getLogger(new Object(){}.getClass().getName());
    {
        logger.addHandler(new ConsoleHandler());
        logger.setLevel(Level.INFO);
    }

    /**
     * The parent PApplet of this library.
     */
    @SuppressWarnings("unused")
    private final PApplet parent;

    private Publisher<? extends MessageDefinition> publisher;

    private Subscriber<? extends MessageDefinition> subscriber;

    private Timer timer;

    private final String name;
    private final Node node;

    /**
     * A constructor, usually called in the setup() method in the sketch
     * to initialize and start the library.
     *
     * @param p the parent PApplet
     * @param nodeName the name for this ROS2 node
     */
    public RCLP9(final PApplet p, final String nodeName) {
        this.parent = Objects.requireNonNull(p);

        RCLJava.init();
        this.name = Objects.requireNonNull(nodeName);
        this.node = RCLJava.createNode(this.name);
        welcome();
    }

    /**
     * Creates an instance of the publisher.
     * @param <T>  any class that extends MessageDefinition, or MessageDefinition itself
     * @param messageType the message type
     * @param topic the topic name
     * @return a publisher instance
     */
    public final <T extends MessageDefinition> Publisher<T> createPublisher(final Class<T> messageType,
            final String topic) {
        var p = node().createPublisher(messageType, topic);
        this.publisher = p;
        return p;
    }

    /**
     * Creates an instance of the subscriber.
     * @param <T> any class that extends MessageDefinition, or MessageDefinition itself
     * @param messageType the message type
     * @param topic the topic name
     * @param callback the callback function
     * @return a subscriber instance
     */
    public final <T extends MessageDefinition> Subscriber<T> createSubscriber(final Class<T> messageType,
            final String topic, Consumer<T> callback) {
        var s = node().createSubscriber(messageType, topic, callback);
        this.subscriber = s;
        return s;
    }

    /**
     * Creates an instance of the wall clock timer.
     * @param period the time interval measured in milliseconds
     * @param callback the callback function
     * @return a timer instance
     */
    public final Timer createWallClockTimer(final long period, final Callback callback) {
        this.timer = node().createTimer(period, TimeUnit.MILLISECONDS, callback);
        return timer;
    }

    /**
     * Anything here will be called whenever the parent sketch shuts down.
     */
    public final void dispose() {
        shutdown();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public Node node() {
        return node;
    }

    /**
     * Publishes a message.
     * @param <T> any class that extends MessageDefinition, or MessageDefinition itself
     * @param message the message to be dispatched
     */
    public final <T extends MessageDefinition> void publish(final T message) {
        publish(Objects.requireNonNull(message), Objects.requireNonNull((Publisher<T>)publisher));
    }

    /**
     * Publishes a message.
     * @param <T> any class that extends MessageDefinition, or MessageDefinition itself
     * @param message the message to be dispatched
     * @param publisher the publisher to invoke
     */
    public final <T extends MessageDefinition> void publish(final T message, final Publisher<T> publisher) {
        Objects.requireNonNull(publisher).publish(Objects.requireNonNull(message));
    }

    /**
     * Gets the default publisher.
     * @return the default publisher
     */
    public final Publisher<? extends MessageDefinition> publisher() {
        return publisher;
    }

    /**
     * Spins the node forever.
     */
    public final void spin() {
        RCLJava.spin(this);
    }

    /** 
     * Spins the node once.
     */
    public final void spinOnce() {
        RCLJava.spinOnce(this);
    }

    /**
     * Shuts down the node.
     */
    public final void shutdown() {
        logger.info("rclp9 is shutting down");
        RCLJava.shutdown();
    }

    /**
     * Gets the default subsriber.
     * @return the default subscriber
     */
    public final Subscriber<? extends MessageDefinition> subscriber() {
        return subscriber;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public final String toString() {
        return ("Instance of " + (new Object(){}.getClass().getName()) + ", name = " + name + ", handle = "
                + node.handle());
    }

    private final void welcome() {
        logger.info("rclp9 is starting");
    }
}
